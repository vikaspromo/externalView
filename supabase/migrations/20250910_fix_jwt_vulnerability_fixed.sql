-- Migration: Fix Critical JWT Email Vulnerability in RLS (Fixed Version)
-- Date: 2025-09-10
-- Purpose: Replace email-based admin checks with secure auth.uid() validation
-- Security Issue: JWT email claims can be forged, allowing unauthorized admin access

-- ============================================================================
-- STEP 1: DROP EXISTING POLICIES FIRST (to avoid dependency errors)
-- ============================================================================

-- Drop all policies that depend on user_has_client_access function
DROP POLICY IF EXISTS "client_access_policy" ON clients;
DROP POLICY IF EXISTS "users_access_policy" ON users;
DROP POLICY IF EXISTS "users_update_policy" ON users;
DROP POLICY IF EXISTS "users_insert_delete_policy" ON users;
DROP POLICY IF EXISTS "users_delete_policy" ON users;
DROP POLICY IF EXISTS "client_org_history_access_policy" ON client_org_history;
DROP POLICY IF EXISTS "client_org_history_modify_policy" ON client_org_history;
DROP POLICY IF EXISTS "client_org_history_update_policy" ON client_org_history;
DROP POLICY IF EXISTS "client_org_history_delete_policy" ON client_org_history;
DROP POLICY IF EXISTS "organizations_read_policy" ON organizations;
DROP POLICY IF EXISTS "organizations_modify_policy" ON organizations;
DROP POLICY IF EXISTS "organizations_update_policy" ON organizations;
DROP POLICY IF EXISTS "organizations_delete_policy" ON organizations;
DROP POLICY IF EXISTS "org_positions_read_policy" ON org_positions;
DROP POLICY IF EXISTS "org_positions_modify_policy" ON org_positions;

-- ============================================================================
-- STEP 2: UPDATE USER_ADMINS TABLE STRUCTURE
-- ============================================================================

-- Add auth_user_id column to link admins to auth.users
ALTER TABLE user_admins 
ADD COLUMN IF NOT EXISTS auth_user_id UUID UNIQUE,
ADD COLUMN IF NOT EXISTS last_verified_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS failed_access_attempts INTEGER DEFAULT 0;

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_user_admins_auth_user_id ON user_admins(auth_user_id);

-- Add foreign key constraint to auth.users (Supabase auth schema)
-- Note: This ensures admin records are linked to real auth users
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'fk_user_admins_auth_user'
  ) THEN
    ALTER TABLE user_admins 
    ADD CONSTRAINT fk_user_admins_auth_user 
    FOREIGN KEY (auth_user_id) 
    REFERENCES auth.users(id) 
    ON DELETE CASCADE;
  END IF;
END $$;

-- ============================================================================
-- STEP 3: CREATE AUDIT LOG TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS security_audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type VARCHAR(50) NOT NULL,
  user_id UUID,
  user_email TEXT,
  client_uuid UUID,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  ip_address INET,
  user_agent TEXT,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for querying audit logs
CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON security_audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_event_type ON security_audit_log(event_type);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON security_audit_log(created_at DESC);

-- Enable RLS on audit log
ALTER TABLE security_audit_log ENABLE ROW LEVEL SECURITY;

-- Only admins can read audit logs (using temporary email check until migration completes)
DROP POLICY IF EXISTS "Only admins can read audit logs" ON security_audit_log;
CREATE POLICY "Only admins can read audit logs" 
ON security_audit_log FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM user_admins 
    WHERE (auth_user_id = auth.uid() OR email = auth.jwt() ->> 'email')
    AND active = true
  )
);

-- ============================================================================
-- STEP 4: MIGRATE EXISTING ADMIN DATA
-- ============================================================================

-- Function to safely migrate admin data
DO $$
DECLARE
  admin_record RECORD;
  auth_user_uuid UUID;
BEGIN
  -- Loop through existing admins
  FOR admin_record IN SELECT * FROM user_admins WHERE auth_user_id IS NULL
  LOOP
    -- Try to find corresponding auth.users record
    SELECT id INTO auth_user_uuid 
    FROM auth.users 
    WHERE email = admin_record.email 
    LIMIT 1;
    
    IF auth_user_uuid IS NOT NULL THEN
      -- Update admin record with auth user id
      UPDATE user_admins 
      SET 
        auth_user_id = auth_user_uuid,
        last_verified_at = NOW()
      WHERE id = admin_record.id;
      
      RAISE NOTICE 'Migrated admin user: % -> %', admin_record.email, auth_user_uuid;
    ELSE
      -- Mark inactive if no auth user found
      UPDATE user_admins 
      SET active = false 
      WHERE id = admin_record.id;
      
      RAISE WARNING 'No auth user found for admin: %, marked inactive', admin_record.email;
    END IF;
  END LOOP;
END $$;

-- ============================================================================
-- STEP 5: CREATE SECURE ADMIN CHECK FUNCTION
-- ============================================================================

-- Drop the old vulnerable function
DROP FUNCTION IF EXISTS user_has_client_access(UUID);

-- Create new secure function using auth.uid()
CREATE OR REPLACE FUNCTION user_has_client_access(p_client_uuid UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
  v_is_admin BOOLEAN := false;
  v_has_access BOOLEAN := false;
  v_user_email TEXT;
BEGIN
  -- Get user email for logging (safe to use for logging only)
  v_user_email := auth.jwt() ->> 'email';
  
  -- Check if user is admin using secure auth.uid()
  SELECT EXISTS (
    SELECT 1 FROM user_admins 
    WHERE auth_user_id = auth.uid() 
    AND active = true
    AND auth_user_id IS NOT NULL  -- Ensure migrated
  ) INTO v_is_admin;
  
  -- If admin, grant access and log it
  IF v_is_admin THEN
    -- Log successful admin access
    INSERT INTO security_audit_log (
      event_type, 
      user_id, 
      user_email,
      client_uuid, 
      success,
      metadata
    ) VALUES (
      'admin_client_access',
      auth.uid(),
      v_user_email,
      p_client_uuid,
      true,
      jsonb_build_object('admin_check', true)
    );
    
    -- Update last verified timestamp
    UPDATE user_admins 
    SET last_verified_at = NOW() 
    WHERE auth_user_id = auth.uid();
    
    RETURN true;
  END IF;
  
  -- Check if regular user belongs to this client
  SELECT EXISTS (
    SELECT 1 FROM users 
    WHERE id::uuid = auth.uid() 
    AND client_uuid = p_client_uuid
  ) INTO v_has_access;
  
  -- Log access attempt if it's cross-client
  IF NOT v_has_access AND auth.uid() IS NOT NULL THEN
    INSERT INTO security_audit_log (
      event_type, 
      user_id, 
      user_email,
      client_uuid, 
      success,
      error_message
    ) VALUES (
      'unauthorized_client_access',
      auth.uid(),
      v_user_email,
      p_client_uuid,
      false,
      'User attempted to access client they do not belong to'
    );
  END IF;
  
  RETURN v_has_access;
END;
$$;

-- ============================================================================
-- STEP 6: CREATE FUNCTION TO CHECK ADMIN STATUS SECURELY
-- ============================================================================

CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_admins 
    WHERE auth_user_id = auth.uid() 
    AND active = true
    AND auth_user_id IS NOT NULL
  );
END;
$$;

-- ============================================================================
-- STEP 7: RECREATE ALL POLICIES WITH SECURE FUNCTIONS
-- ============================================================================

-- CLIENTS TABLE
CREATE POLICY "client_access_policy" 
ON clients FOR ALL 
USING (user_has_client_access(uuid))
WITH CHECK (user_has_client_access(uuid));

-- USERS TABLE
CREATE POLICY "users_access_policy" 
ON users FOR SELECT 
USING (user_has_client_access(client_uuid));

CREATE POLICY "users_update_policy" 
ON users FOR UPDATE 
USING (
  user_has_client_access(client_uuid) 
  AND (
    id::uuid = auth.uid() 
    OR is_admin()
  )
)
WITH CHECK (
  user_has_client_access(client_uuid) 
  AND (
    id::uuid = auth.uid()
    OR is_admin()
  )
);

CREATE POLICY "users_insert_policy" 
ON users FOR INSERT 
WITH CHECK (is_admin());

CREATE POLICY "users_delete_policy" 
ON users FOR DELETE 
USING (is_admin());

-- CLIENT_ORG_HISTORY TABLE
CREATE POLICY "client_org_history_access_policy" 
ON client_org_history FOR SELECT 
USING (user_has_client_access(client_uuid));

CREATE POLICY "client_org_history_modify_policy" 
ON client_org_history FOR INSERT 
WITH CHECK (user_has_client_access(client_uuid));

CREATE POLICY "client_org_history_update_policy" 
ON client_org_history FOR UPDATE 
USING (user_has_client_access(client_uuid))
WITH CHECK (user_has_client_access(client_uuid));

CREATE POLICY "client_org_history_delete_policy" 
ON client_org_history FOR DELETE 
USING (user_has_client_access(client_uuid));

-- ORGANIZATIONS TABLE
CREATE POLICY "organizations_read_policy" 
ON organizations FOR SELECT 
USING (auth.uid() IS NOT NULL);

CREATE POLICY "organizations_modify_policy" 
ON organizations FOR INSERT 
WITH CHECK (is_admin());

CREATE POLICY "organizations_update_policy" 
ON organizations FOR UPDATE 
USING (is_admin())
WITH CHECK (is_admin());

CREATE POLICY "organizations_delete_policy" 
ON organizations FOR DELETE 
USING (is_admin());

-- ORG_POSITIONS TABLE
CREATE POLICY "org_positions_read_policy" 
ON org_positions FOR SELECT 
USING (auth.uid() IS NOT NULL);

CREATE POLICY "org_positions_modify_policy" 
ON org_positions FOR ALL 
USING (is_admin())
WITH CHECK (is_admin());

-- ============================================================================
-- STEP 8: CREATE RATE LIMITING FUNCTION
-- ============================================================================

CREATE OR REPLACE FUNCTION check_rate_limit(p_user_id UUID, p_limit INTEGER DEFAULT 100)
RETURNS BOOLEAN
LANGUAGE plpgsql
AS $$
DECLARE
  v_request_count INTEGER;
BEGIN
  -- Count requests in last minute
  SELECT COUNT(*) INTO v_request_count
  FROM security_audit_log
  WHERE user_id = p_user_id
  AND created_at > NOW() - INTERVAL '1 minute';
  
  IF v_request_count > p_limit THEN
    -- Log rate limit violation
    INSERT INTO security_audit_log (
      event_type, 
      user_id, 
      success,
      error_message
    ) VALUES (
      'rate_limit_exceeded',
      p_user_id,
      false,
      format('User exceeded rate limit: %s requests in 1 minute', v_request_count)
    );
    
    RETURN false;
  END IF;
  
  RETURN true;
END;
$$;

-- ============================================================================
-- STEP 9: GRANT NECESSARY PERMISSIONS
-- ============================================================================

GRANT EXECUTE ON FUNCTION user_has_client_access(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION check_rate_limit(UUID, INTEGER) TO authenticated;

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================

-- Check that all admins are properly linked
SELECT 
  email, 
  auth_user_id,
  active,
  CASE 
    WHEN auth_user_id IS NULL THEN 'NOT MIGRATED - VULNERABLE'
    ELSE 'SECURE'
  END as security_status
FROM user_admins;

-- Check for any remaining vulnerable policies
SELECT 
  tablename,
  policyname,
  qual
FROM pg_policies
WHERE schemaname = 'public'
AND qual::text LIKE '%auth.jwt()%email%';

-- ============================================================================
-- SUCCESS MESSAGE
-- ============================================================================
DO $$
BEGIN
  RAISE NOTICE '==================================================';
  RAISE NOTICE 'JWT VULNERABILITY FIX APPLIED SUCCESSFULLY';
  RAISE NOTICE 'Admin authentication now uses secure auth.uid()';
  RAISE NOTICE 'Audit logging is enabled for all access attempts';
  RAISE NOTICE '==================================================';
END $$;

-- ============================================================================
-- ROLLBACK INFORMATION
-- ============================================================================
-- To rollback this migration, run the rollback script:
-- supabase/migrations/rollback_jwt_fix.sql