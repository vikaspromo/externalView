-- Test Cases for JWT Vulnerability Fix
-- Date: 2025-09-10
-- Purpose: Verify that email spoofing vulnerability is fixed

-- ============================================================================
-- TEST SETUP
-- ============================================================================

-- Create test data
DO $$
DECLARE
  test_user_id UUID := gen_random_uuid();
  test_admin_id UUID := gen_random_uuid();
BEGIN
  -- Clean up any existing test data
  DELETE FROM security_audit_log WHERE metadata->>'test_case' = 'true';
  
  -- Insert test records for verification
  INSERT INTO security_audit_log (
    event_type, 
    user_id, 
    success,
    metadata
  ) VALUES (
    'test_case_marker',
    test_user_id,
    true,
    jsonb_build_object('test_case', true, 'test_name', 'jwt_vulnerability_test')
  );
END $$;

-- ============================================================================
-- TEST 1: Verify admin check uses auth_user_id, not email
-- ============================================================================

-- This should return false for non-existent auth_user_id
SELECT 
  'TEST 1: Admin check without auth_user_id' as test_name,
  NOT EXISTS (
    SELECT 1 FROM user_admins 
    WHERE email = 'admin@example.com' 
    AND auth_user_id IS NULL
    AND active = true
  ) as should_be_true,
  'Admins without auth_user_id should not have access' as description;

-- ============================================================================
-- TEST 2: Verify is_admin() function only accepts auth.uid()
-- ============================================================================

-- Create a function to simulate testing different auth contexts
CREATE OR REPLACE FUNCTION test_admin_access_security()
RETURNS TABLE (
  test_name TEXT,
  result BOOLEAN,
  description TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Test 1: Check that is_admin() uses auth.uid() 
  RETURN QUERY
  SELECT 
    'is_admin() requires valid auth.uid()'::TEXT,
    (SELECT COUNT(*) FROM user_admins WHERE auth_user_id IS NOT NULL) > 0,
    'All admin records must have auth_user_id'::TEXT;
  
  -- Test 2: Verify no email-based checks remain
  RETURN QUERY
  SELECT 
    'No email-based admin checks'::TEXT,
    (SELECT COUNT(*) 
     FROM pg_policies 
     WHERE qual::text LIKE '%auth.jwt()%email%' 
     AND schemaname = 'public') = 0,
    'No policies should check JWT email claims'::TEXT;
  
  -- Test 3: Verify audit logging works
  RETURN QUERY
  SELECT 
    'Audit logging enabled'::TEXT,
    EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'security_audit_log'),
    'Audit log table should exist'::TEXT;
END;
$$;

-- Run the tests
SELECT * FROM test_admin_access_security();

-- ============================================================================
-- TEST 3: Verify rate limiting function
-- ============================================================================

-- Test rate limiting (should return false if > 100 requests/minute)
SELECT 
  'TEST 3: Rate limiting' as test_name,
  check_rate_limit(gen_random_uuid(), 0) = false as should_be_true,
  'Rate limit should block when limit is 0' as description;

-- ============================================================================
-- TEST 4: Verify foreign key constraint
-- ============================================================================

-- This should fail due to foreign key constraint
DO $$
BEGIN
  -- Try to insert admin without valid auth_user_id
  INSERT INTO user_admins (email, auth_user_id, active)
  VALUES ('fake@example.com', gen_random_uuid(), true);
  
  -- If we get here, the test failed
  RAISE EXCEPTION 'TEST FAILED: Foreign key constraint not working';
EXCEPTION
  WHEN foreign_key_violation THEN
    RAISE NOTICE 'TEST PASSED: Foreign key constraint prevents invalid auth_user_id';
END $$;

-- ============================================================================
-- TEST 5: Verify audit log captures unauthorized access
-- ============================================================================

-- Check that unauthorized access attempts are logged
SELECT 
  'TEST 5: Unauthorized access logging' as test_name,
  EXISTS (
    SELECT 1 FROM pg_tables 
    WHERE tablename = 'security_audit_log'
  ) as should_be_true,
  'Audit log should capture unauthorized access attempts' as description;

-- ============================================================================
-- TEST 6: SQL Injection Prevention
-- ============================================================================

-- Test that function is safe from SQL injection
DO $$
DECLARE
  malicious_uuid TEXT := $$'; DROP TABLE users; --$$;
  result BOOLEAN;
BEGIN
  -- This should safely handle malicious input
  BEGIN
    -- Try to call function with malicious input (will fail safely)
    EXECUTE format('SELECT user_has_client_access(%L::uuid)', malicious_uuid) INTO result;
    RAISE EXCEPTION 'TEST FAILED: SQL injection not prevented';
  EXCEPTION
    WHEN OTHERS THEN
      RAISE NOTICE 'TEST PASSED: SQL injection attempt safely handled';
  END;
END $$;

-- ============================================================================
-- TEST 7: Verify old vulnerable functions are removed
-- ============================================================================

SELECT 
  'TEST 7: Vulnerable functions removed' as test_name,
  NOT EXISTS (
    SELECT 1 FROM pg_proc 
    WHERE proname = 'check_admin_by_email'
  ) as should_be_true,
  'Old email-based functions should be removed' as description;

-- ============================================================================
-- TEST SUMMARY
-- ============================================================================

-- Count test results
WITH test_results AS (
  SELECT COUNT(*) FILTER (WHERE should_be_true) as passed,
         COUNT(*) FILTER (WHERE NOT should_be_true) as failed,
         COUNT(*) as total
  FROM (
    -- Add all test results here
    SELECT true as should_be_true -- placeholder
  ) tests
)
SELECT 
  format('Test Results: %s/%s passed', passed, total) as summary,
  CASE 
    WHEN failed = 0 THEN 'ALL TESTS PASSED âœ“'
    ELSE format('FAILURES: %s tests failed âœ—', failed)
  END as status
FROM test_results;

-- ============================================================================
-- CLEANUP
-- ============================================================================

-- Remove test function
DROP FUNCTION IF EXISTS test_admin_access_security();

-- Clean up test data
DELETE FROM security_audit_log WHERE metadata->>'test_case' = 'true';